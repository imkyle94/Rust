// 모든 프로그램은 실행 중인 동안에 어떠한 방법으로든 컴퓨터의 메모리를 관리해야 한다.
// 가비지 콜렉터를 이용해 더 이상 사용되지 않는 메모리를 지속적으로 찾아 자동으로 해제하는 행위
// 등으로 말이다.
// 또 다른 언어는 프로그래머가 명시적으로 메모리를 할당하고 해제해 주어야 한다.
// 러스트는 제 3의 방법을 사용한다. 메모리는 컴파일러가 컴파일 시점에 검사하는 다양한 규칙으로
// 이루어진 소유권 시스템애 의해 관리된다.
// 따라서, 소유권과 관련된 기능은 프로그램의 실행 성능에 아무런 영향을 미치지 않는다.
// 소유권 시스템의 규칙에 익숙해질수록 더 안전하며 효율적인 코드를 작성할 수 있다.
fn main() {
    // 변수 s는 프로그램 안에 하드코딩한 문자열값인 문자열 리터럴을 참조한다.
    let s = "hello";

    // 앞서 언급한 데이터 타입 절에서의 데이터 타입들은 모두 스택에 저장되며 범위를 벗어나면
    // 스택에서 제거되지만, 힙에 저장되는 데이터를 살펴보자.

    // 문자열은 불변이기 때문에 실용적이지 않다. 이를 대비에 러스트는 String 타입을 제공한다.
    // String 타입은 힙에 할당된다. 따라서 컴파일 시점에 알 수 없는 크기의 문자열을 저장할 수 있다.

    let mut s = String::from("hello");
    s.push_str(", world!");
    println!("{}", s);
    // from 함수를 이용해 인스턴스를 생성했다.


    // 변수가 데이터와 상호작용하는 방식 : 이동(Move)
    let x = 5;
    let y = x;
    // 정수는 이미 알려진 고정 크기의 단순 값이기 때문에 5라는 값 두 개가 스택에 저장된다.
    
    let s1 = String::from("hello");
    let s2 = s1;
    // String 타입은 문자열 콘텐츠를 저장하고 있는 메모리에 대한 포인터, 길이, 용량 3 부분으로
    // 구성된다. 이 데이터는 스택에 저장된다. (['h','e','l','l','0'] 이런 느낌으로)
    // 길이는 String 타입의 콘텐츠가 현재 어느 정도의 메모리를 사용 중인지 바이트 단위로 표현한
    // 값이며,
    // 용량은 String 타입이 운영체제로부터 할당받은 총 메모리를 바이트로 표현한 값이다.
    //
    // 변수 s1을 s2에 대입하면 String 타입의 데이터가 복사된다. 즉, 포인터가 가리키는 힙 메모리의
    // 실제 데이터가 아니라 문자열에 대한 포인터와 길이, 용량이 스택에 복사된다.
    // 그런데 여기서 중괄호를 만나 범위가 벗어났다고 가정하자.
    // 그러면, 메모리 해제(drop)이 일어날 것인데 두 변수가 모두 같은 메모리를 해제하려고 하기
    // 때문에 메모리 안전성 버그 중 하나인 해제 에러가 발생한다.
    //
    // 여기서 러스트 특징이 하나 더 있다.
    // s2 = s1 행위에서 러스트는 할당된 메모리를 복사하면서 s1이 더이상 유효하지 않다고 판단하기
    // 때문에 s1은 다시 불러들일 수 없다.
    //
    // 그리고, 방금 포인터, 길이, 용량을 복사한 행위가 타 언어에서 얕은 복사와 깊은 복사와
    // 유사하다고 생각할 수 있지만, 러스트는 s1을 아예 무효화해버리므로 러스트에서는 이를
    // 이동(Move)이라고 부른다.
    //
    // 러스트는 절대 자동으로 데이터에 대한 깊은 복사를 수행하지 않는다. 그래서 런타임 성능
    // 관점에서 볼 때, 모든 자동 복사 작업은 매우 가벼운 작업이다.
    //

   // 변수와 데이터가 상호작용하는 방식 : 복제(Clone)
   // 만일 스택 데이터가 아니라 힙 메모리에 저장된 String 데이터를 복사하기 원한다면 clone이라는
   // 공통 메서드를 사용하면 된다.
   let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
// 이는 메모리의 크기에 따라 무거운 작업이 될 수도 있다.

    // 스택 전용 데이터 : 복사(Copy)
    let x= 5;
    let y= x;

    println!("x = {}, y = {}", x, y);
    // 정수형 같은 타입은 컴파일 시점에 이미 그 크기를 알 수 있으며, 온전히 스택에 저장되지 때문에
    // 실제 값을 복사해도 전혀 부담되지 않는다. 즉, 변수 x를 변수 y에 대입한 후에 무효화할 이유가
    // 전혀 없다는 것이다. 다시 말하면 깊은 복사와 얕은 복사의 차이가 전혀 없으므로 clone 메서드를
    // 호출한다해도 통상적인 얕은 복사와 아무런 차이점이 발생하지 않는다.

    // 러스트는 스택에 저장되는 정수형 같은 타입에 적용할 수 있는 Copy 트레이트(trait)라는 특별한
    // 특성을 제공한다. 만일 어떤 타입에 Copy 트레이트가 적용되어 있다면 이전 변수를 새 변수에
    // 할당해도 무효화되지 않는다. 다만, 어떤 타입, 혹은 그 타입의 어느 일부에 Drop 트레이트가
    // 적용되어 있으면 Copy 트레이트를 적용할 수 없다.
    //
    // Copy 트레이트가 적용된 예제로는
    // - u32와 같은 모든 정수형 타입
    // - true, false 값만을 가지는 불리언 타입, bool
    // - 문자 타입, char
    // - f64와 같은 모든 부동 소수점 타입
    // - Copy 트레이트가 적용된 타입을 포함하는 튜플.
    // 즉 (i32, i32)는 가능, (i32, String)는 불가능.

}
